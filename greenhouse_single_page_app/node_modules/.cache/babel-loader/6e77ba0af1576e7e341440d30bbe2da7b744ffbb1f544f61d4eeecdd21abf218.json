{"ast":null,"code":"import { resolveComponent as _resolveComponent, createVNode as _createVNode, toDisplayString as _toDisplayString, createTextVNode as _createTextVNode, withCtx as _withCtx, createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  class: \"chart-container hourly-chart-container\"\n};\nconst _hoisted_2 = {\n  ref: \"hourlyChartCanvas\"\n};\nconst _hoisted_3 = {\n  class: \"chart-container weekly-chart-container\"\n};\nconst _hoisted_4 = {\n  ref: \"weeklyChartCanvas\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_to_do_icon = _resolveComponent(\"to-do-icon\");\n  const _component_base_button = _resolveComponent(\"base-button\");\n  const _component_base_card = _resolveComponent(\"base-card\");\n  return _openBlock(), _createElementBlock(\"div\", null, [_createVNode(_component_base_card, null, {\n    default: _withCtx(() => [_createElementVNode(\"h3\", null, [_createVNode(_component_base_button, null, {\n      default: _withCtx(() => [_createVNode(_component_to_do_icon, {\n        iconwidth: \"25\",\n        class: \"icon\"\n      }), _createTextVNode(\" Drill Down on \" + _toDisplayString($props.dataLabel), 1 /* TEXT */)]),\n      _: 1 /* STABLE */\n    })])]),\n    _: 1 /* STABLE */\n  }), _createVNode(_component_base_card, null, {\n    default: _withCtx(() => [_cache[0] || (_cache[0] = _createElementVNode(\"h4\", null, \"Last 24 Hours\", -1 /* HOISTED */)), _createElementVNode(\"div\", _hoisted_1, [_createElementVNode(\"canvas\", _hoisted_2, null, 512 /* NEED_PATCH */)])]),\n    _: 1 /* STABLE */\n  }), _createVNode(_component_base_card, null, {\n    default: _withCtx(() => [_cache[1] || (_cache[1] = _createElementVNode(\"h4\", null, \"Past 7 Days (Hourly Data)\", -1 /* HOISTED */)), _createElementVNode(\"div\", _hoisted_3, [_createElementVNode(\"canvas\", _hoisted_4, null, 512 /* NEED_PATCH */)])]),\n    _: 1 /* STABLE */\n  })]);\n}","map":{"version":3,"names":["class","ref","_createElementBlock","_createVNode","_component_base_card","default","_withCtx","_createElementVNode","_component_base_button","_component_to_do_icon","iconwidth","_createTextVNode","_toDisplayString","$props","dataLabel","_","_hoisted_1","_hoisted_2","_hoisted_3","_hoisted_4"],"sources":["/home/alex/dev/greenhouse_single_page_app/src/pages/greenhouse/GhDrillDown.vue"],"sourcesContent":["<template>\n  <div>\n    <base-card>\n      <h3>\n        <base-button>\n          <to-do-icon iconwidth=\"25\" class=\"icon\"></to-do-icon>\n          Drill Down on {{ dataLabel }}\n        </base-button>\n      </h3>\n    </base-card>\n\n    <base-card>\n      <h4>Last 24 Hours</h4>\n      <div class=\"chart-container hourly-chart-container\">\n        <canvas ref=\"hourlyChartCanvas\"></canvas>\n      </div>\n    </base-card>\n\n    <base-card>\n      <h4>Past 7 Days (Hourly Data)</h4>\n       <div class=\"chart-container weekly-chart-container\">\n            <canvas ref=\"weeklyChartCanvas\"></canvas>\n       </div>\n    </base-card>\n\n  </div>\n</template>\n\n<script>\nimport { Chart, registerables } from 'chart.js';\n// *** Make sure you have run: npm install chartjs-adapter-date-fns date-fns ***\nimport 'chartjs-adapter-date-fns';\n// ***************************************************************************\nChart.register(...registerables);\n\n// Import base components if they are not globally registered\nimport BaseCard from '@/components/UI/BaseCard.vue';\nimport BaseButton from '@/components/UI/BaseButton.vue';\nimport ToDoIcon from '@/components/UI/icons/ToDoIcon.vue'; // Adjust path if necessary\n\n\nexport default {\n  components: {\n      BaseCard,\n      BaseButton,\n      ToDoIcon\n      // Register other components used in the template if needed\n  },\n  props: {\n    dataLabel: { // Keep prop even if not used for data fetching *yet*\n      type: String,\n      required: true,\n    }\n  },\n  data() {\n    return {\n      // Chart instances\n      hourlyChartInstance: null,\n      weeklyChartInstance: null,\n      // Sample data storage\n      hourlySampleData: [],\n      weeklyHourlySampleData: [],\n    };\n  },\n  computed: {\n    // Formatter for the hourly chart data (uses explicit labels)\n    formattedHourlyChartData() {\n      if (!this.hourlySampleData || this.hourlySampleData.length === 0) {\n        return { labels: [], datasets: [{ label: 'Temperature (°C)', data: [] }] };\n      }\n      const labels = this.hourlySampleData.map(item => item.timeLabel);\n      const dataPoints = this.hourlySampleData.map(item => item.value);\n      return {\n        labels: labels, // X-axis labels (e.g., \"14:00\")\n        datasets: [\n          {\n            label: 'Temperature (°C)',\n            data: dataPoints, // Y-axis values\n            borderColor: '#74ad7d',\n            backgroundColor: 'rgba(116, 173, 125, 0.2)',\n            tension: 0.1,\n            fill: true,\n            // --- Styling for 'x' markers (defined per dataset) ---\n            pointStyle: 'crossRot',\n            pointRadius: 6,\n            pointBorderWidth: 2,\n            pointBackgroundColor: 'rgba(0,0,0,0.5)',\n            // ----------------------------------------------------\n          }\n        ]\n      };\n    },\n\n    // Formatter for the weekly chart using HOURLY data points ({x, y})\n    formattedWeeklyChartData() {\n       if (!this.weeklyHourlySampleData || this.weeklyHourlySampleData.length === 0) {\n         return { datasets: [{ label: 'Temperature (°C)', data: [] }] };\n       }\n       return {\n         // No separate labels array needed when using {x,y} format for time scale\n         datasets: [\n          {\n            label: 'Temperature (°C)', // Dataset label\n            data: this.weeklyHourlySampleData.map(item => ({\n                x: new Date(item.timestamp), // Use Date object or timestamp for x\n                y: item.value                // The temperature value for y\n            })),\n            borderColor: '#36A2EB',\n            backgroundColor: 'rgba(54, 162, 235, 0.2)',\n            tension: 0.1, // Smoothes the line slightly\n            fill: true,\n            // Point radius 0 to hide points is set in the chart options below\n          }\n        ]\n      };\n    }\n  },\n  methods: {\n    // Generates 24h of hourly data\n    generateHourlySampleData() {\n      const data = [];\n      const now = new Date(); // Current time\n      const baseTemp = 15;\n      const variation = 5;\n      for (let i = 23; i >= 0; i--) {\n        const timestamp = new Date(now.getTime() - i * 60 * 60 * 1000);\n        const temp = baseTemp + (Math.random() - 0.5) * 2 * variation;\n        data.push({\n          timestamp: timestamp.toISOString(),\n          value: parseFloat(temp.toFixed(1)),\n          timeLabel: timestamp.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit', hour12: false })\n        });\n      }\n      this.hourlySampleData = data;\n    },\n\n    // Generates 7 days of HOURLY data\n    generateWeeklyHourlySampleData() {\n       const data = [];\n       const now = new Date(); // Current time\n       const hoursToGoBack = 7 * 24; // 168 hours\n       const baseTemp = 14;\n       const variation = 4;\n       // Removed unused firstTimestamp and lastTimestamp declarations\n\n       for (let i = hoursToGoBack - 1; i >= 0; i--) { // Loop through hours\n         const timestamp = new Date(now.getTime() - i * 60 * 60 * 1000);\n         // Removed assignments to unused firstTimestamp/lastTimestamp\n         const temp = baseTemp + (Math.random() - 0.5) * 2 * variation;\n         data.push({\n           timestamp: timestamp.toISOString(), // Store full timestamp\n           value: parseFloat(temp.toFixed(1)),\n         });\n       }\n       this.weeklyHourlySampleData = data;\n    },\n\n    // Render hourly chart\n    renderHourlyChart() {\n      if (!this.$refs.hourlyChartCanvas) return;\n      const ctx = this.$refs.hourlyChartCanvas.getContext('2d');\n      if (this.hourlyChartInstance) this.hourlyChartInstance.destroy();\n      if (!this.hourlySampleData || this.hourlySampleData.length === 0) return;\n\n      const formattedData = this.formattedHourlyChartData;\n      if (!formattedData || !formattedData.datasets || !formattedData.datasets[0] || !formattedData.datasets[0].data || formattedData.datasets[0].data.length === 0) {\n           console.error(\"Formatted hourly data is invalid or empty!\");\n           return;\n      }\n\n      try {\n          this.hourlyChartInstance = new Chart(ctx, {\n            type: 'line',\n            data: formattedData, // Use the local variable fixed the ReferenceError\n            options: {\n              responsive: true,\n              maintainAspectRatio: false,\n              scales: {\n                x: { title: { display: true, text: 'Time (Last 24h)' } },\n                y: { beginAtZero: false, title: { display: true, text: 'Temperature (°C)' } },\n              },\n              plugins: {\n                legend: { display: false },\n                title: { display: true, text: 'Hourly Temperature (°C)' },\n                tooltip: { enabled: true }\n              }\n            }\n          });\n      } catch (error) {\n           console.error(\"Error creating hourly chart:\", error);\n      }\n    },\n\n    // Render weekly chart with HOURLY data points and time scale\n    renderWeeklyChart() {\n        if (!this.$refs.weeklyChartCanvas) return;\n        // Corrected: getContext from the specific ref\n        const ctx = this.$refs.weeklyChartCanvas.getContext('2d');\n        if (this.weeklyChartInstance) this.weeklyChartInstance.destroy();\n        if (!this.weeklyHourlySampleData || this.weeklyHourlySampleData.length === 0) return;\n\n        // *** Determine min/max timestamps from the actual data ***\n        // Convert ISO strings back to time values for comparison\n        const timestamps = this.weeklyHourlySampleData.map(d => new Date(d.timestamp).getTime());\n        // Add checks in case timestamps array is empty\n        const minTimestamp = timestamps.length ? Math.min(...timestamps) : null;\n        const maxTimestamp = timestamps.length ? Math.max(...timestamps) : null;\n        // *********************************************************\n\n        const formattedData = this.formattedWeeklyChartData;\n        if (!formattedData || !formattedData.datasets || !formattedData.datasets[0] || !formattedData.datasets[0].data || formattedData.datasets[0].data.length === 0) {\n           console.error(\"Formatted weekly data is invalid or empty!\");\n           return;\n        }\n\n        // Only proceed if min/max calculation was successful\n        if (minTimestamp === null || maxTimestamp === null) {\n            console.error(\"Could not determine min/max timestamps for weekly chart.\");\n            return;\n        }\n\n        try {\n            this.weeklyChartInstance = new Chart(ctx, {\n                type: 'line',\n                data: formattedData, // Uses the {x, y} data structure\n                options: {\n                    responsive: true,\n                    maintainAspectRatio: false,\n                     scales: {\n                         y: {\n                             beginAtZero: false,\n                             title: { display: true, text: 'Temperature (°C)'}\n                         },\n                         x: {\n                             type: 'time', // *** Enable time scale ***\n                             title: { display: true, text: 'Date / Time'},\n                             time: {\n                                 unit: 'day', // Display labels primarily by day\n                                 tooltipFormat: 'PPp', // Format for tooltips (e.g., Apr 13, 2025, 3:00 PM)\n                             },\n                             ticks: {\n                                 source: 'auto',\n                                 maxRotation: 45,\n                                 minRotation: 45\n                             },\n                             // *** Explicitly set min/max for the axis ***\n                             min: minTimestamp,\n                             max: maxTimestamp\n                             // ******************************************\n                         }\n                    },\n                     plugins: {\n                        legend: { display: false },\n                        title: { display: true, text: 'Weekly Temperature Trend (°C)'},\n                        tooltip: { enabled: true }\n                     },\n                     elements: {\n                         point:{\n                             radius: 0 // *** Hide points on this chart ***\n                         }\n                     },\n                     parsing: false, // Optimization\n                     normalized: true, // Optimization\n                }\n            });\n        } catch(error) {\n             console.error(\"Error creating weekly chart:\", error);\n        }\n    }\n  },\n  created() {\n    // Generate both datasets immediately\n    this.generateHourlySampleData();\n    this.generateWeeklyHourlySampleData();\n  },\n  mounted() {\n    // Render charts after component is mounted\n    // Using nextTick ensures DOM elements (canvas) are definitely ready\n    this.$nextTick(() => {\n        this.renderHourlyChart();\n        this.renderWeeklyChart();\n    });\n  },\n  beforeUnmount() {\n    // Clean up both chart instances\n    if (this.hourlyChartInstance) this.hourlyChartInstance.destroy();\n    if (this.weeklyChartInstance) this.weeklyChartInstance.destroy();\n  },\n}\n</script>\n\n<style scoped>\n.icon {\n  margin-right: 10px;\n}\n\n/* Style the container div to control chart size */\n.chart-container {\n  position: relative; /* Needed for responsive chart sizing */\n  width: 350px;\n  height: 200px;\n  margin: 20px auto; /* Add vertical margin between elements/cards */\n}\n\n/* Canvas itself should fill the container */\ncanvas {\n  display: block; /* Prevents extra space below canvas */\n  width: 100%;\n  height: 100%;\n}\n</style>"],"mappings":";;EAaWA,KAAK,EAAC;AAAwC;;EACzCC,GAAG,EAAC;AAAmB;;EAM3BD,KAAK,EAAC;AAAwC;;EACtCC,GAAG,EAAC;AAAmB;;;;;uBApBzCC,mBAAA,CAwBM,cAvBJC,YAAA,CAOYC,oBAAA;IAThBC,OAAA,EAAAC,QAAA,CAGM,MAKK,CALLC,mBAAA,CAKK,aAJHJ,YAAA,CAGcK,sBAAA;MAPtBH,OAAA,EAAAC,QAAA,CAKU,MAAqD,CAArDH,YAAA,CAAqDM,qBAAA;QAAzCC,SAAS,EAAC,IAAI;QAACV,KAAK,EAAC;UAL3CW,gBAAA,CAK+D,iBACvC,GAAAC,gBAAA,CAAGC,MAAA,CAAAC,SAAS,iB;MANpCC,CAAA;;IAAAA,CAAA;MAWIZ,YAAA,CAKYC,oBAAA;IAhBhBC,OAAA,EAAAC,QAAA,CAYM,MAAsB,C,0BAAtBC,mBAAA,CAAsB,YAAlB,eAAa,sBACjBA,mBAAA,CAEM,OAFNS,UAEM,GADJT,mBAAA,CAAyC,UAAzCU,UAAyC,8B;IAdjDF,CAAA;MAkBIZ,YAAA,CAKYC,oBAAA;IAvBhBC,OAAA,EAAAC,QAAA,CAmBM,MAAkC,C,0BAAlCC,mBAAA,CAAkC,YAA9B,2BAAyB,sBAC5BA,mBAAA,CAEM,OAFNW,UAEM,GADDX,mBAAA,CAAyC,UAAzCY,UAAyC,8B;IArBrDJ,CAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}